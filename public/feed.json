{
  "version": "https://jsonfeed.org/version/1",
  "title": "François Petitit",
  "home_page_url": "http://localhost:1313/",
  "feed_url": "http://localhost:1313/feed.json",
  "description": "François Petitit",
  "favicon": "http://localhost:1313//assets/favicon.ico",
  "expired": false,
  "author": {
    "name": "François Petitit",
    "url": "http://localhost:1313/"
  },
  "items": [
    
    

    
    {
      "id": "b365f886c6540df51d5423c319a4b664794095c0",
      "title": "Paris Web Openid Connect France Connect",
      "summary": "",
      "content_text": " OpenID Connect, le nouveau standard d\u0026#039;authentification sur le web : mise en oeuvre sur FranceConnect from Paris Web on Vimeo.\n",
      "content_html": "\u003ciframe src=\"https://player.vimeo.com/video/143169752?h=e8a06887a2\" width=\"640\" height=\"360\" frameborder=\"0\" allow=\"autoplay; fullscreen; picture-in-picture\" allowfullscreen\u003e\u003c/iframe\u003e\n\u003cp\u003e\u003ca href=\"https://vimeo.com/143169752\"\u003eOpenID Connect, le nouveau standard d\u0026#039;authentification sur le web : mise en oeuvre sur FranceConnect\u003c/a\u003e from \u003ca href=\"https://vimeo.com/parisweb\"\u003eParis Web\u003c/a\u003e on \u003ca href=\"https://vimeo.com\"\u003eVimeo\u003c/a\u003e.\u003c/p\u003e",
      "url": "http://localhost:1313/posts/paris-web-openid-connect-france-connect/",
      "date_published": "4046-04-09T41:44:00+02:00",
      "date_modified": "4046-04-09T41:44:00+02:00",
      "author": {
        "name": "François Petitit",
        "url": "http://localhost:1313/"
      }
    },
    
    {
      "id": "ddab5ff15afb8acd087338c06d0e5c19e22f1dee",
      "title": "How We Used React Virtualized to Boost Our Sale Page",
      "summary": "",
      "content_text": "This article was previously published here : https://medium.com/la-ruche-qui-dit-oui/how-we-used-react-virtualized-to-boost-our-sale-page-6e2f087039ca\nHow we used React Virtualized to boost our sale page Our mission at La Ruche qui dit Oui ! is to provide good and fair products to our customers, directly from farmers and craftsmen.\nSince last year, we have been working to improve and expand our product offerings, bringing more and more producers and more and more products to our customers.\nChallenges arise at many levels: logistics, communication, marketing, but also the user experience offered by our website.\nThis article focuses on what we did, as Web developers, to handle more and more farmers and more and more products on our new sale page :\nBut before getting to the code, let’s see what we wanted to change on this page.\nThe old sale page: why we chose to abandon it The sale page looked like that, until the last few weeks:\nWhen this page was designed and implemented, there were only dozens or a few hundreds products per sale. It worked fine at the beginning, but as the number of offers was growing up, we identified some limitations that were problematic:\na fundamental pattern of our navigation wasn’t understood by the user, especially the newcomers: the products are ordered by farms (because we want to highlight our farmers). Some users dropped their orders or had to spend more time to compare the products, and as you know, on a e-commerce website, more time means less sales… on iOS devices, the browser crashed when there were too many products — due to a lack of memory. We used a pagination but it made the sale harder to navigate. on large screens, the products were also displayed by batches of 20: when the user was coming to a category, the first 20 were displayed, then when the user scrolled to the bottom, the next 20 were added at the bottom of the list, and so on. Fast scrolling navigation was a bit jerky. on large screen, the page didn’t use all the width of the page: it was a shame because we could have displayed more products. access to categories, subcategories and organic filters was only possible when the user was on top of the page. Discovering the whole range of products was not easy and organic filters deserved to be more visible. So, we needed to improve the discoverability of the whole catalog, and the navigation inside it.\nAfter a few weeks of user testing and design adjustments, we finally decided to implement this new page:\nThe main technical challenge of the new sale page was the “all products” category:\nAs you may guess viewing the screenshot, there are now 2 ways to navigate inside a category:\nthe user can scroll into the products list, from the first product to the last one (sometimes there are more than 2000 products). or the user can click on a farm in the farms list on the left side: the list will automatically scroll up or down to the first product of the farmer. So, let’s see how we handled displaying long lists and browsing into them in our code.\nHandle long list with React : React-virtualized At La Ruche qui dit Oui !, we chose about 2 years ago to develop all our new Web front-end features with React.\nReact is very powerful to manipulate the DOM efficiently thanks to its use of shadow DOM. We aim to provide the most fluid and responsive interfaces thanks to React.\nIn its documentation, React provides some guidelines to optimize performances. In particular, there is a paragraph about “Virtualize Long Lists” :\nVirtualize Long Lists\nIf your application renders long lists of data (hundreds or thousands of rows), we recommended using a technique known as “windowing”. This technique only renders a small subset of your rows at any given time, and can dramatically reduce the time it takes to re-render the components as well as the number of DOM nodes created.\nReact Virtualized is one popular windowing library. It provides several reusable components for displaying lists, grids, and tabular data. You can also create your own windowing component, like Twitter did, if you want something more tailored to your application’s specific use case.\nWindowing is pretty easy to understand with the capture below, displaying the content of the DOM at a precise moment : only a dozen of rows are rendered into the DOM, no matter the total number of rows. React Virtualized will remove the rows that are no longer visible and add the newly visible each time the user scrolls into the page.\nSo as the documentation mentioned React Virtualized, and as it seemed to handle our use cases, we chose to use it to implement the new features.\nHow we use React Virtualized We managed to isolate all our usage of React Virtualized in only one component, called “ProductsList.jsx”.\nFinally, we used 2 components from the library: List and WindowScroller. Our imports look like this:\nNote that the explicit path used in the import directives are due to the recommendation from here and could be removed if you’re using Webpack 4.\nList allows to display a windowed list of elements.\nWindowScroller allows the List component to be scrolled based on the window\u0026rsquo;s scroll positions. Also, the scrollbar will reflect the length of the list and the current position.\nNow let’s render these components in the render function of our ProductsList component:\nThe properties passed to the List component can be divided in 3 parts: the content of the list, the dimensions of the list, and handling the user interactions.\n###The content of the list\nGiving the content is done by passing a function as the rowRenderer property, that will return the React component corresponding to the index of the desired row:\n(R is for RamdaJS)\nWhere farmsAndProductsComponents is a pre-computed array that contains React components displaying either a farmer card or a product card. This part of the code is pretty obvious, but will be complicated to handle the dimension of the list.\nHandling the dimension of the list One of the key thing that must be done to handle the scrollbar of the window is to be able to know the size of the entire list.\nSo we set fixed height to our components, according to their types (farmer card or product card) and the width of the window (the cards heights are bigger on small screen than on large screen), and passed the function as the rowHeight prop:\nhttps://gist.github.com/fpetitit/5f94f76477670b6db561fb1f885509f7\nHandling the user interaction If we stopped here, the user could scroll into the list, use the scrollbar, and know where it situated into the list.\nBut we wanted to provide an other way to navigate, by displaying the list of the producers, displaying the current producer (the one corresponding to the first visible product in the screen), and going to an other producer by clicking on its name. This is the purpose of the menu on the left side, in large screen:\nThe producers list in the sticky menu\nDisplaying the current farm To do that, we added a “scrollY” attribute to our list components:\nhttps://gist.github.com/fpetitit/bd6c592cd76cd7417be8e35078f34a55\nIt allowed us to determine the current producer by looking for the first element of the list having a scrollY visible according to window.pageYOffset:\nhttps://gist.github.com/fpetitit/c9e3de2a22182e9a9995eb94c70847c0\nGoing to a specific producer Finally, going to a specific producer was done by calculating the position of the producer card by accumulating the heights of the previous components from the list and scrolling to the position:\nhttps://gist.github.com/fpetitit/60995479f18922d6caf54dcd602376d2\nConclusion : the pros and cons of React Virtualized We are quite happy of our new sale page and React Virtualized was really a great tool to help use prototyping and developing all the features that we wanted.\nThe performance are very good, it works well on all the browsers that we support, especially on the most difficult to support for us which are IE 11 and Safari Mobile on relatively old iOS devices.\nWe were concerned by 2 problems until now. Both are due to the fact that the whole list is never present into the DOM:\nsearching into the list by the find function of the browsers (“ctrl + f”) is working only in the visible rows, but we provide a Search functionality in the sale page that the user should use instead of the browser’s function, and that provides more intelligent results some CSS rules cannot be used, for example selectors like first-of-type If you have faced challenges of the same type, please share your experiences in the comments of this blog post :)\n",
      "content_html": "\u003cp\u003eThis article was previously published here : \u003ca href=\"https://medium.com/la-ruche-qui-dit-oui/how-we-used-react-virtualized-to-boost-our-sale-page-6e2f087039ca\"\u003ehttps://medium.com/la-ruche-qui-dit-oui/how-we-used-react-virtualized-to-boost-our-sale-page-6e2f087039ca\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"how-we-used-react-virtualized-to-boost-our-sale-page\"\u003eHow we used React Virtualized to boost our sale page\u003c/h1\u003e\n\u003cp\u003eOur mission at \u003ca href=\"https://laruchequiditoui.fr/fr\"\u003eLa Ruche qui dit Oui !\u003c/a\u003e is to provide good and fair products to our customers, directly from farmers and craftsmen.\u003c/p\u003e\n\u003cp\u003eSince last year, we have been working to improve and expand our product offerings, bringing more and more producers and more and more products to our customers.\u003c/p\u003e\n\u003cp\u003eChallenges arise at many levels: logistics, communication, marketing, but also the user experience offered by our website.\u003c/p\u003e\n\u003cp\u003eThis article focuses on what we did, as Web developers, to handle more and more farmers and more and more products on our new sale page :\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"image.png\"\n  alt=\"Our new sale page\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eBut before getting to the code, let’s see what we wanted to change on this page.\u003c/p\u003e\n\u003ch2 id=\"the-old-sale-page-why-we-chose-to-abandon-it\"\u003eThe old sale page: why we chose to abandon it\u003c/h2\u003e\n\u003cp\u003eThe sale page looked like that, until the last few weeks:\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"image-1.png\"\n  alt=\"Farewell, old page\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eWhen this page was designed and implemented, there were only dozens or a few hundreds products per sale. It worked fine at the beginning, but as the number of offers was growing up, we identified some limitations that were problematic:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ea fundamental pattern of our navigation wasn’t understood by the user, especially the newcomers: the products are ordered by farms (because we want to highlight our farmers). Some users dropped their orders or had to spend more time to compare the products, and as you know, on a e-commerce website, more time means less sales…\u003c/li\u003e\n\u003cli\u003eon iOS devices, the browser crashed when there were too many products — due to a lack of memory. We used a pagination but it made the sale harder to navigate.\u003c/li\u003e\n\u003cli\u003eon large screens, the products were also displayed by batches of 20: when the user was coming to a category, the first 20 were displayed, then when the user scrolled to the bottom, the next 20 were added at the bottom of the list, and so on. Fast scrolling navigation was a bit jerky.\u003c/li\u003e\n\u003cli\u003eon large screen, the page didn’t use all the width of the page: it was a shame because we could have displayed more products.\u003c/li\u003e\n\u003cli\u003eaccess to categories, subcategories and organic filters was only possible when the user was on top of the page. Discovering the whole range of products was not easy and organic filters deserved to be more visible.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo, we needed to improve the discoverability of the whole catalog, and the navigation inside it.\u003c/p\u003e\n\u003cp\u003eAfter a few weeks of user testing and design adjustments, we finally decided to implement this new page:\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"image-2.png\"\n  alt=\"The home screen of the new sale page : a selection of products\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eThe main technical challenge of the new sale page was the “all products” category:\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"image-3.png\"\n  alt=\"The “All products” category\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eAs you may guess viewing the screenshot, there are now 2 ways to navigate inside a category:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ethe user can scroll into the products list, from the first product to the last one (sometimes there are more than 2000 products).\u003c/li\u003e\n\u003cli\u003eor the user can click on a farm in the farms list on the left side: the list will automatically scroll up or down to the first product of the farmer.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo, let’s see how we handled displaying long lists and browsing into them in our code.\u003c/p\u003e\n\u003ch2 id=\"handle-long-list-with-react--react-virtualized\"\u003eHandle long list with React : React-virtualized\u003c/h2\u003e\n\u003cp\u003eAt La Ruche qui dit Oui !, we chose about 2 years ago to develop all our new Web front-end features with React.\u003c/p\u003e\n\u003cp\u003eReact is very powerful to manipulate the DOM efficiently thanks to its use of shadow DOM. We aim to provide the most fluid and responsive interfaces thanks to React.\u003c/p\u003e\n\u003cp\u003eIn its documentation, React provides some guidelines to optimize performances. In particular, there is a paragraph about “Virtualize Long Lists” :\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eVirtualize Long Lists\u003c/p\u003e\n\u003cp\u003eIf your application renders long lists of data (hundreds or thousands of rows), we recommended using a technique known as “windowing”. This technique only renders a small subset of your rows at any given time, and can dramatically reduce the time it takes to re-render the components as well as the number of DOM nodes created.\u003c/p\u003e\n\u003cp\u003eReact Virtualized is one popular windowing library. It provides several reusable components for displaying lists, grids, and tabular data. You can also create your own windowing component, like Twitter did, if you want something more tailored to your application’s specific use case.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eWindowing is pretty easy to understand with the capture below, displaying the content of the DOM at a precise moment : only a dozen of rows are rendered into the DOM, no matter the total number of rows. React Virtualized will remove the rows that are no longer visible and add the newly visible each time the user scrolls into the page.\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"image-4.png\"\n  alt=\"At every moment, only a subset of the whole list is present in the DOM\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\u003c/p\u003e\n\u003cp\u003eSo as the documentation mentioned React Virtualized, and as it seemed to handle our use cases, we chose to use it to implement the new features.\u003c/p\u003e\n\u003ch2 id=\"how-we-use-react-virtualized\"\u003eHow we use React Virtualized\u003c/h2\u003e\n\u003cp\u003eWe managed to isolate all our usage of React Virtualized in only one component, called “ProductsList.jsx”.\u003c/p\u003e\n\u003cp\u003eFinally, we used 2 components from the library: List and WindowScroller. Our imports look like this:\u003c/p\u003e\n\u003cscript src=\"https://gist.github.com/fpetitit/775ba62467c257c737f4d413902ab5ab.js\"\u003e\u003c/script\u003e\n\u003cp\u003eNote that the explicit path used in the import directives are due to the recommendation from \u003ca href=\"https://medium.com/la-ruche-qui-dit-oui/how-we-used-react-virtualized-to-boost-our-sale-page-6e2f087039ca#:~:text=the%20recommendation%20from-,here,-and%20could%20be\"\u003ehere\u003c/a\u003e and could be removed if you’re using Webpack 4.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eList\u003c/code\u003e allows to display a windowed list of elements.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eWindowScroller\u003c/code\u003e allows the \u003ccode\u003eList\u003c/code\u003e component to be scrolled based on the window\u0026rsquo;s scroll positions. Also, the scrollbar will reflect the length of the list and the current position.\u003c/p\u003e\n\u003cp\u003eNow let’s render these components in the \u003ccode\u003erender\u003c/code\u003e function of our \u003ccode\u003eProductsList\u003c/code\u003e component:\u003c/p\u003e\n\u003cscript src=\"https://gist.github.com/fpetitit/79e217389fb23d42d0789bdedcee53cf.js\"\u003e\u003c/script\u003e\n\u003cp\u003eThe properties passed to the List component can be divided in 3 parts: the content of the list, the dimensions of the list, and handling the user interactions.\u003c/p\u003e\n\u003cp\u003e###The content of the list\u003c/p\u003e\n\u003cp\u003eGiving the content is done by passing a function as the rowRenderer property, that will return the React component corresponding to the index of the desired row:\u003c/p\u003e\n\u003cscript src=\"https://gist.github.com/fpetitit/499eb8cbe1b32ebef85251b9d6598196.js\"\u003e\u003c/script\u003e\n\u003cp\u003e(R is for \u003ca href=\"http://ramdajs.com/\"\u003eRamdaJS\u003c/a\u003e)\u003c/p\u003e\n\u003cp\u003eWhere farmsAndProductsComponents is a pre-computed array that contains React components displaying either a farmer card or a product card. This part of the code is pretty obvious, but will be complicated to handle the dimension of the list.\u003c/p\u003e\n\u003ch3 id=\"handling-the-dimension-of-the-list\"\u003eHandling the dimension of the list\u003c/h3\u003e\n\u003cp\u003eOne of the key thing that must be done to handle the scrollbar of the window is to be able to know the size of the entire list.\u003c/p\u003e\n\u003cp\u003eSo we set fixed height to our components, according to their types (farmer card or product card) and the width of the window (the cards heights are bigger on small screen than on large screen), and passed the function as the rowHeight prop:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://gist.github.com/fpetitit/5f94f76477670b6db561fb1f885509f7\"\u003ehttps://gist.github.com/fpetitit/5f94f76477670b6db561fb1f885509f7\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"handling-the-user-interaction\"\u003eHandling the user interaction\u003c/h3\u003e\n\u003cp\u003eIf we stopped here, the user could scroll into the list, use the scrollbar, and know where it situated into the list.\u003c/p\u003e\n\u003cp\u003eBut we wanted to provide an other way to navigate, by displaying the list of the producers, displaying the current producer (the one corresponding to the first visible product in the screen), and going to an other producer by clicking on its name. This is the purpose of the menu on the left side, in large screen:\u003c/p\u003e\n\u003cp\u003e\u003cimg\n  src=\"image-5.png\"\n  alt=\"The producers list in the sticky menu\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  class=\"full-width\"\n/\u003e\n\n\nThe producers list in the sticky menu\u003c/p\u003e\n\u003ch3 id=\"displaying-the-current-farm\"\u003eDisplaying the current farm\u003c/h3\u003e\n\u003cp\u003eTo do that, we added a “scrollY” attribute to our list components:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://gist.github.com/fpetitit/bd6c592cd76cd7417be8e35078f34a55\"\u003ehttps://gist.github.com/fpetitit/bd6c592cd76cd7417be8e35078f34a55\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eIt allowed us to determine the current producer by looking for the first element of the list having a scrollY visible according to \u003ccode\u003ewindow.pageYOffset\u003c/code\u003e:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://gist.github.com/fpetitit/c9e3de2a22182e9a9995eb94c70847c0\"\u003ehttps://gist.github.com/fpetitit/c9e3de2a22182e9a9995eb94c70847c0\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"going-to-a-specific-producer\"\u003eGoing to a specific producer\u003c/h3\u003e\n\u003cp\u003eFinally, going to a specific producer was done by calculating the position of the producer card by accumulating the heights of the previous components from the list and scrolling to the position:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://gist.github.com/fpetitit/60995479f18922d6caf54dcd602376d2\"\u003ehttps://gist.github.com/fpetitit/60995479f18922d6caf54dcd602376d2\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"conclusion--the-pros-and-cons-of-react-virtualized\"\u003eConclusion : the pros and cons of React Virtualized\u003c/h3\u003e\n\u003cp\u003eWe are quite happy of our new sale page and React Virtualized was really a great tool to help use prototyping and developing all the features that we wanted.\u003c/p\u003e\n\u003cp\u003eThe performance are very good, it works well on all the browsers that we support, especially on the most difficult to support for us which are IE 11 and Safari Mobile on relatively old iOS devices.\u003c/p\u003e\n\u003cp\u003eWe were concerned by 2 problems until now. Both are due to the fact that the whole list is never present into the DOM:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003esearching into the list by the find function of the browsers (“ctrl + f”) is working only in the visible rows, but we provide a Search functionality in the sale page that the user should use instead of the browser’s function, and that provides more intelligent results\u003c/li\u003e\n\u003cli\u003esome CSS rules cannot be used, for example selectors like \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/:first-of-type\"\u003efirst-of-type\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf you have faced challenges of the same type, please share your experiences in the comments of this blog post :)\u003c/p\u003e\n",
      "url": "http://localhost:1313/posts/how-we-used-react-virtualized-to-boost-our-sale-page/",
      "date_published": "18076-18-09T752:1818:00+02:00",
      "date_modified": "18076-18-09T752:1818:00+02:00",
      "author": {
        "name": "François Petitit",
        "url": "http://localhost:1313/"
      }
    },
    
    {
      "id": "c919fa3e91246abacf6c5945fe7bbb0a71be85bd",
      "title": "Paris Web Atelier HTML5 Pour Mon Ordinateur Et Mon Mobile",
      "summary": "",
      "content_text": "In 2010, with my friend and former colleague Mickael Morier, I presented a workshop at Paris Web entitled \u0026ldquo;HTML5 for my computer and my mobile\u0026rdquo;.\n",
      "content_html": "\u003cp\u003eIn 2010, with my friend and former colleague Mickael Morier, I presented a workshop at \u003ca href=\"https://www.paris-web.fr/\"\u003eParis Web\u003c/a\u003e entitled \u0026ldquo;HTML5 for my computer and my mobile\u0026rdquo;.\u003c/p\u003e\n\u003ciframe src=\"http://www.dailymotion.com/embed/video/xh43oe?logo=0\" width=\"594\" height=\"475\" frameborder=\"0\"\u003e\u003c/iframe\u003e",
      "url": "http://localhost:1313/posts/paris-web-atelier-html5-pour-mon-ordinateur-et-mon-mobile/",
      "date_published": "10106-10-09T1046:1010:00+02:00",
      "date_modified": "10106-10-09T1046:1010:00+02:00",
      "author": {
        "name": "François Petitit",
        "url": "http://localhost:1313/"
      }
    }
    
  ]
}